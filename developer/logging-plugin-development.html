<!DOCTYPE html>
<html>
<head>
  <title>Logging Plugin Development</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Greg Schueler" />
  <meta name="date" content="June 5, 2013" />
  <link rel="stylesheet" href="../style.css" type="text/css" />
</head>
<body>
<div class="rundecksite">
<nav class="site" >
      <ul  class="container_12">
    <li class="item index grid_4 alpha">
    <a href="http://rundeck.org/index.html">
      <h1>Rundeck</h1>
      <p class="rd_version">Open-Source Workflow Automation</p>
      </a>
    </li>
    <li class="item about grid_2 selected">
      <a href="http://rundeck.org/about.html">
        <h1>About</h1>
        <p>News, Videos, Docs</p>
      </a>
    </li>
    <li class="item help grid_2">
      <a href="http://rundeck.org/help.html">
        <h1>Get Help</h1>
        <p>IRC List Tracker</p>
      </a>
    </li>
    <li class="item plugins grid_2">
      <a href="http://rundeck.org/plugins/index.html">
        <h1>Plugins</h1>
        <p>Integrate Rundeck</p>
      </a>
    </li>
    <li class="item downloads grid_2 omega">
    <a href="http://rundeck.org/downloads.html">
      <h1>Download</h1>
      <p class="rd_version">1.6.2</p>
      </a>
    </li>
<div class="clear"></div>
</ul>
    </nav>
    <div class="container_12 searchbox">
    <div class="grid_4 prefix_8">
        <form action="http://rundeck.org/search/">
            <input type="search" name="q"/>
            <input type="submit" value="Search"/>
        </form>
    </div>
<div class="clear"></div>
</div>
</div>

<nav class="breadcrumb top">
    <ul>
        <li><a href="../index.html">Rundeck Documentation (1.6.2)</a></li>
    </ul>
</nav>

<nav class="page top">
    <ul>
        <li class="current"><a href="logging-plugin-development.html">Logging Plugin Development</a></li>
        <li class="toc"><a href="index.html">Developer Guide</a></li>
        <li class="prev"><a href="workflow-step-plugin-development.html">Workflow Step Plugin Development</a></li>
        <li class="next"><a href="plugin-development.html">Plugin Development</a></li>
    </ul>
</nav>
<div id="docbody">
<h1 class="title">Logging Plugin Development</h1>
<div id="TOC"
><ul
  ><li
    ><a href="#about-rundeck-logging"
      >About Rundeck Logging</a
      ></li
    ><li
    ><a href="#types-of-logging-plugins"
      >Types of Logging Plugins</a
      ></li
    ><li
    ><a href="#configuration"
      >Configuration</a
      ></li
    ><li
    ><a href="#logging-plugin-development"
      >Logging Plugin Development</a
      ><ul
      ><li
	><a href="#java-logging-plugins"
	  >Java Logging plugins</a
	  ></li
	><li
	><a href="#groovy-logging-plugins"
	  >Groovy Logging plugins</a
	  ></li
	></ul
      ></li
    ><li
    ><a href="#example-code"
      >Example code</a
      ></li
    ><li
    ><a href="#execution-context-data"
      >Execution Context Data</a
      ></li
    ><li
    ><a href="#streaminglogwriter"
      >StreamingLogWriter</a
      ><ul
      ><li
	><a href="#java-streaminglogwriter"
	  >Java StreamingLogWriter</a
	  ></li
	><li
	><a href="#groovy-streaminglogwriter"
	  >Groovy StreamingLogWriter</a
	  ></li
	></ul
      ></li
    ><li
    ><a href="#streaminglogreader"
      >StreamingLogReader</a
      ><ul
      ><li
	><a href="#java-streaminglogreader"
	  >Java StreamingLogReader</a
	  ></li
	><li
	><a href="#groovy-streaminglogreader"
	  >Groovy StreamingLogReader</a
	  ></li
	></ul
      ></li
    ><li
    ><a href="#logfilestorage"
      >LogFileStorage</a
      ><ul
      ><li
	><a href="#storage-behavior"
	  >Storage behavior</a
	  ></li
	><li
	><a href="#retrieval-behavior"
	  >Retrieval behavior</a
	  ></li
	><li
	><a href="#log-file-availability"
	  >Log File Availability</a
	  ></li
	><li
	><a href="#java-logfilestorage"
	  >Java LogFileStorage</a
	  ></li
	><li
	><a href="#groovy-logfilestorage"
	  >Groovy LogFileStorage</a
	  ></li
	></ul
      ></li
    ></ul
  ></div
>
<div id="about-rundeck-logging"
><h2
  ><a href="#TOC"
    >About Rundeck Logging</a
    ></h2
  ><p
  >When Rundeck executes a Job or adhoc execution, it runs workflow steps across multiple nodes and channels all output from these steps into a log for the execution. This log contains the output from each step, as well as metadata about the context that the event occurred in, such as the node name, date stamp, and contextual data about the step being executed.</p
  ><p
  >This logging system consists of these components:</p
  ><ul
  ><li
    ><em
      >Streaming Log Writers</em
      > - One or more outputs for the log data</li
    ><li
    ><em
      >Streaming Log Reader</em
      > - One input for reading the log data</li
    ></ul
  ><p
  >When an execution starts, it writes log events to all outputs until it is done. When a user views the execution log in the Rundeck GUI, or accesses it via the API, the input component is used to read the log events for the specific Execution.</p
  ><p
  >Rundeck provides a built-in Reader and Writer, by writing the log output to a formatted file on disk, stored in the <code
    >var/logs</code
    > directory. This is the <strong
    >Local File Log</strong
    >.</p
  ><p
  >However local storage of log files is not always ideal, such as when deploying of Rundeck in a cloud environment where local disk storage could be ephemeral, or when clustering multiple Rundeck servers. In those cases, it would be useful to have a way to store the log file somewhere else, and retrieve it when necessary.</p
  ><p
  >Rundeck now has another component:</p
  ><ul
  ><li
    ><em
      >Log File Storage</em
      > - A way of storing and retrieving log file data in an external system</li
    ></ul
  ><p
  >Rundeck has a plugin mechanism for all three of these logging components, allowing the logging system to be adapted to different needs.</p
  ><p
  >Events are written to all configured Writer plugins, as well as the <strong
    >Local File Log</strong
    > if not disabled:</p
  ><div class="figure"
  ><img src="../figures/log%20storage1.png" alt="Writer plugins"
     /><p class="caption"
    >Writer plugins</p
    ></div
  ><p
  >Events are read from either a Reader plugin, or the <strong
    >Local File Log</strong
    >:</p
  ><div class="figure"
  ><img src="../figures/log%20storage2.png" alt="Reader plugins"
     /><p class="caption"
    >Reader plugins</p
    ></div
  ><p
  >When the <strong
    >Local File Log</strong
    > is used, the logs can be asynchronously stored to a Storage plugin after they are completed. Later, the logs can be asynchronously retrieved via the Storage plugin to be used by the <strong
    >Local File Log</strong
    >:</p
  ><div class="figure"
  ><img src="../figures/log%20storage3.png" alt="Storage plugins"
     /><p class="caption"
    >Storage plugins</p
    ></div
  ><p
  >Here are some examples of how it can be used:</p
  ><ul
  ><li
    >replace the <strong
      >Local File Log</strong
      > entirely with another Reader and set of Writers</li
    ><li
    >duplicate all log output somewhere, in addition to using the <strong
      >Local File Log</strong
      ></li
    ><li
    >Supplement the <strong
      >Local File Log</strong
      > with a secondary log file storage system, so that local files can be removed and restored as needed</li
    ></ul
  ></div
><div id="types-of-logging-plugins"
><h2
  ><a href="#TOC"
    >Types of Logging Plugins</a
    ></h2
  ><p
  >There are three types of plugins that can be created:</p
  ><ul
  ><li
    ><a href="#streaminglogwriter"
      >StreamingLogWriter</a
      > - provides a stream-like mechanism for writing log events</li
    ><li
    ><a href="#streaminglogreader"
      >StreamingLogReader</a
      > - provides a stream-like mechanism for reading log events</li
    ><li
    ><a href="#logfilestorage"
      >LogFileStorage</a
      > - provides a way to both store and retrieve entire log files</li
    ></ul
  ></div
><div id="configuration"
><h2
  ><a href="#TOC"
    >Configuration</a
    ></h2
  ><p
  >See the chapter <a href="../manual/plugins.html#logging"
    >Plugins - Using Providers - Logging</a
    >.</p
  ></div
><div id="logging-plugin-development"
><h2
  ><a href="#TOC"
    >Logging Plugin Development</a
    ></h2
  ><p
  >Rundeck supports two development modes for Logging plugins:</p
  ><ol style="list-style-type: decimal;"
  ><li
    >Java-based development deployed as a Jar file.</li
    ><li
    >Groovy-based deployed as a single <code
      >.groovy</code
      > script.</li
    ></ol
  ><p
  >Currently &quot;script-based&quot; plugins (shell scripts, that is) are not supported.</p
  ><div id="java-logging-plugins"
  ><h3
    ><a href="#TOC"
      >Java Logging plugins</a
      ></h3
    ><p
    >Java-based plugins can be developed just as any other Rundeck plugin, as described in the chapter <a href="#java-plugin-development"
      >Plugin Development - Java Plugin Development</a
      >.</p
    ><p
    >Your plugin class should implement the appropriate Java interface as described in the section for that plugin:</p
    ><ul
    ><li
      ><a href="#streaminglogwriter"
	>StreamingLogWriter</a
	></li
      ><li
      ><a href="#streaminglogreader"
	>StreamingLogReader</a
	></li
      ><li
      ><a href="#logfilestorage"
	>LogFileStorage</a
	></li
      ></ul
    ><p
    >To define configuration properties for your plugin, you use the same mechanisms as for Workflow Steps, described under the chapter <a href="workflow-step-plugin-development.html#plugin-descriptions"
      >Workflow Step Plugin Development - Plugin Descriptions</a
      >.</p
    ><p
    >The simplest way to do this is to use <a href="workflow-step-plugin-development.html#description-annotations"
      >Description Annotations</a
      >.</p
    ></div
  ><div id="groovy-logging-plugins"
  ><h3
    ><a href="#TOC"
      >Groovy Logging plugins</a
      ></h3
    ><p
    >The Groovy plugin development method for Loggig Plugins is similar to <a href="notification-plugin-development.html#groovy-plugins"
      >Notification Plugin Development - Groovy Plugins</a
      >.</p
    ><p
    >Create a Groovy script, and define your plugin by calling the <code
      >rundeckPlugin</code
      > method, and pass it both the Class of the type of plugin, and a Closure used to build the plugin object.</p
    ><pre
    ><code
      >import com.dtolabs.rundeck.plugins.logging.StreamingLogWriterPlugin
rundeckPlugin(StreamingLogWriterPlugin){
    //plugin definition goes here...
}
</code
      ></pre
    ></div
  ></div
><div id="example-code"
><h2
  ><a href="#TOC"
    >Example code</a
    ></h2
  ><p
  >See the source directory <code
    >examples/example-groovy-log-plugins</code
    > for examples of all three provider types written in Groovy.</p
  ><ul
  ><li
    >On github: <a href="https://github.com/dtolabs/rundeck/tree/development/examples/example-groovy-log-plugins"
      >example-groovy-log-plugins</a
      ></li
    ></ul
  ><p
  >See the source directory <code
    >examples/example-java-logging-plugins</code
    > for Java examples.</p
  ><ul
  ><li
    >On github: <a href="https://github.com/dtolabs/rundeck/tree/development/examples/example-java-logging-plugins"
      >example-java-logging-plugins</a
      ></li
    ></ul
  ></div
><div id="execution-context-data"
><h2
  ><a href="#TOC"
    >Execution Context Data</a
    ></h2
  ><p
  >All three plugin types are given a Map of Execution &quot;context data&quot;. This is a dataset with information about the Execution that produced the log events.</p
  ><p
  >This data map is the same as the &quot;Job context variables&quot; available when you execute a job or adhoc script, as described in the chapter <a href="../manual/job-workflows.html#context-variables"
    >Job Workflows - Context Variables</a
    >.</p
  ><p
  >Note that the Map keys will not start with <code
    >job.</code
    >, simply use the variable name, such as <code
    >execid</code
    >.</p
  ></div
><div id="streaminglogwriter"
><h2
  ><a href="#TOC"
    >StreamingLogWriter</a
    ></h2
  ><p
  >The <code
    >StreamingLogWriter</code
    > system receives log events from an execution and writes them somewhere.</p
  ><p
  >The Java interface for these plugins is:</p
  ><pre
  ><code
    >com.dtolabs.rundeck.plugins.logging.StreamingLogWriterPlugin
</code
    ></pre
  ><div id="java-streaminglogwriter"
  ><h3
    ><a href="#TOC"
      >Java StreamingLogWriter</a
      ></h3
    ><p
    >Create a Java class that implements the <a href="https://github.com/dtolabs/rundeck/tree/core/src/main/java/com/dtolabs/rundeck/plugins/logging/StreamingLogWriterPlugin.java"
      >StreamingLogWriterPlugin</a
      > interface:</p
    ><pre
    ><code
      >/**
 * Plugin interface for streaming log writers
 */
public interface StreamingLogWriterPlugin extends StreamingLogWriter {
    /**
     * Sets the execution context information for the log information being written, will be called prior to other
     * methods {@link #openStream()}
     *
     * @param context
     */
    public void initialize(Map&lt;String, ? extends Object&gt; context);
}
</code
      ></pre
    ><p
    >This extends <a href="https://github.com/dtolabs/rundeck/tree/core/src/main/java/com/dtolabs/rundeck/core/logging/StreamingLogWriter.java"
      >StreamingLogWriter</a
      >:</p
    ><pre
    ><code
      >/**
 * writes log entries in a streaming manner
 */
public interface StreamingLogWriter {
    /**
     * Open a stream, called before addEvent is called
     */
    void openStream() throws IOException;

    /**
     * Add a new event
     * @param event
     */
    void addEvent(LogEvent event);

    /**
     * Close the stream.
     */
    void close();
}
</code
      ></pre
    ><p
    >The plugin is used in this manner:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >When the plugin is instantiated, any configuration properties defined that have values to be resolved are set on the plugin instance</li
      ><li
      >the <code
	>initialize</code
	> method is called with a map of <a href="#execution-context-data"
	>contextual data</a
	> about the execution</li
      ><li
      >When an execution starts, the <code
	>openStream</code
	> method is called</li
      ><li
      >For every log event that is emitted by the execution, each plugin's <code
	>addEvent</code
	> is called with the event</li
      ><li
      >After execution finishes, <code
	>close</code
	> is called.</li
      ></ol
    ></div
  ><div id="groovy-streaminglogwriter"
  ><h3
    ><a href="#TOC"
      >Groovy StreamingLogWriter</a
      ></h3
    ><p
    >Create a groovy script that calls the <code
      >rundeckPlugin</code
      > method and passes the <code
      >StreamingLogWriterPlugin</code
      > as the type of plugin:</p
    ><pre
    ><code
      >import com.dtolabs.rundeck.plugins.logging.StreamingLogWriterPlugin
rundeckPlugin(StreamingLogWriterPlugin){
    //plugin definition
}
</code
      ></pre
    ><p
    >To define metadata about your plugin, and configuration properties, see the <a href="notification-plugin-development.html#definition"
      >Notification Plugin Development - Groovy Notification Plugins - DSL - Definition</a
      > chapter.</p
    ><p
    >Define these closures inside your definition:</p
    ><p
    ><code
      >open</code
      ></p
    ><pre
    ><code
      >/**
 * The &quot;open&quot; closure is called to open the stream for writing events.
 * It is passed two map arguments, the execution data, and the plugin configuration data.
 *
 * It should return a Map containing the stream context, which will be passed back for later
 * calls to the &quot;addEvent&quot; closure.
 */
open { Map execution, Map config -&gt;
    //open a stream for writing
    //return a map containing any context you want to maintain
    [mycounter: ..., mystream: ... ]
}
</code
      ></pre
    ><p
    ><code
      >addEvent</code
      ></p
    ><pre
    ><code
      >/**
 * &quot;addEvent&quot; closure is called to append a new event to the stream.  
 * It is passed the Map of stream context created in the &quot;open&quot; closure, and a LogEvent
 * 
 */
addEvent { Map context, LogEvent event-&gt;
   // write the event to my stream
}
</code
      ></pre
    ><p
    ><code
      >close</code
      ></p
    ><pre
    ><code
      >/**
 * &quot;close&quot; closure is called to end writing to the stream.
 *
 * In this example we don't declare any arguments, but an implicit 'context' variable is available with the stream
 * context data.
 */
close { Map context -&gt;
    // close my stream
}
</code
      ></pre
    ><p
    >The plugin is used in this manner:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >When an execution starts, the <code
	>open</code
	> closure is called with both the <a href="#execution-context-data"
	>contextual data</a
	> about the execution, and any configuration property values. The returned context map is kept to pass to later calls</li
      ><li
      >For every log event that is emitted by the execution, each plugin's <code
	>addEvent</code
	> is called with the event and the context map created by <code
	>open</code
	></li
      ><li
      >After execution finishes, <code
	>close</code
	> is called with the context map.</li
      ></ol
    ></div
  ></div
><div id="streaminglogreader"
><h2
  ><a href="#TOC"
    >StreamingLogReader</a
    ></h2
  ><p
  >The <code
    >StreamingLogReader</code
    > system reads log events from somewhere for a specific execution and returns them in an iterator-like fashion. Readers must also support an &quot;offset&quot;, allowing the event stream to resume from some index within the stream. These offset indices can be opaque to Rundeck (they could correspond to bytes, or event number, it is up to the plugin). The plugin is expected to report an offset value when reading events, and be able to resume from a previously reported offset value.</p
  ><p
  >Additionally, these plugins should be able to report a <code
    >totalSize</code
    > (in an opaque manner), and a <code
    >lastModified</code
    > timestamp, indicating the last log event timestamp that was received.</p
  ><p
  >The Java interface for these plugins is:</p
  ><pre
  ><code
    >com.dtolabs.rundeck.plugins.logging.StreamingLogReaderPlugin
</code
    ></pre
  ><div id="java-streaminglogreader"
  ><h3
    ><a href="#TOC"
      >Java StreamingLogReader</a
      ></h3
    ><p
    >Create a Java class that implements the <a href="https://github.com/dtolabs/rundeck/tree/core/src/main/java/com/dtolabs/rundeck/plugins/logging/StreamingLogReaderPlugin.java"
      >StreamingLogReaderPlugin</a
      > interface:</p
    ><pre
    ><code
      >/**
 * Plugin interface for streaming log readers
 */
public interface StreamingLogReaderPlugin extends StreamingLogReader {
    /**
     * Sets the execution context information for the log information being requested, will be called
     * prior to other methods {@link #openStream(Long)}, and must return true to indicate the stream is ready to be open, false otherwise.
     * @param context execution context data
     * @return true if the stream is ready to open
     */
    public boolean initialize(Map&lt;String, ? extends Object&gt; context);

}
</code
      ></pre
    ><p
    >This extends <a href="https://github.com/dtolabs/rundeck/tree/core/src/main/java/com/dtolabs/rundeck/core/logging/StreamingLogReader.java"
      >StreamingLogReader</a
      > interface:</p
    ><pre
    ><code
      >/**
 *  Reads log events in a streaming manner, and supports resuming from a specified offset.
 *
 *  @see LogEventIterator
 *  @see OffsetIterator
 *  @see Closeable
 *  @see CompletableIterator
 */
public interface StreamingLogReader extends LogEventIterator, Closeable {
    /**
     * Read log entries starting at the specified offset
     *
     * @param offset
     *
     * @return
     */
    void openStream(Long offset) throws IOException;

    /**
     * Return the total size
     *
     * @return
     */
    long getTotalSize();

    /**
     * Return the last modification time of the log (e.g. last log entry time, or null if not modified)
     *
     * @return
     */
    Date getLastModified();
}
</code
      ></pre
    ><p
    >Additional methods that must be implemented from super-interfaces:</p
    ><pre
    ><code
      >//from LogEventIterator
LogEvent next();
boolean hasNext();
void remove(); //unused

/**
 * Returns the current opaque offset within the underlying data stream
 *
 * @return
 */
long getOffset(); //from OffsetIterator

/**
 * Return true if the underlying source is completely exhausted, whether
 * or not there are any items to produce (may return false even if {@link Iterator#hasNext()} returns false).
 * @return true if underlying iteration source is exhasuted
 */
boolean isComplete(); //from CompletableIterator
</code
      ></pre
    ><p
    >The plugin is used in this manner:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >When the plugin is instantiated, any configuration properties defined that have values to be resolved are set on the plugin instance</li
      ><li
      >the <code
	>initialize</code
	> method is called with a map of <a href="#execution-context-data"
	>contextual data</a
	> about the execution, if the method returns false, then clients are told that the log stream is pending.</li
      ><li
      >the <code
	>getLastModified</code
	> method may be called, to determine if there are new events since a read sequence</li
      ><li
      >The <code
	>openStream</code
	> method is called, possibly with an offset larger than 0, which indicates the event stream should begin at the specified offset</li
      ><li
      >The <code
	>java.util.Iterator</code
	> methods will be called to iterate all available LogEvents</li
      ><li
      >The <code
	>isComplete</code
	> method will be called to determine if the log output is complete, or may contain more entries later.</li
      ><li
      >The <code
	>getOffset</code
	> method will be called to record the last offset read.</li
      ><li
      >Finally, <code
	>close</code
	> is called.</li
      ></ol
    ><p
    >Rundeck uses this interface to read the log events to display in the GUI, or send out via its API. It uses the <code
      >offset</code
      >, as well as <code
      >lastModified</code
      >, to resume reading the log from a certain point, and to check whether there is more data since the last time it was read.</p
    ><p
    >The implementation of the <code
      >isComplete</code
      > method is important, because it signals to Rundeck that all log events for the stream have been read and no more are expected to be available. To be clear, this differs from the <code
      >java.util.Iterator#hasNext()</code
      > method, which returns true if any events are actually available. <code
      >isComplete</code
      > should return false until no more events will ever be available.</p
    ><p
    >If you are developing a <code
      >StreamingLogWriter</code
      > in conjuction with a <code
      >StreamingLogReader</code
      >, keep in mind that the writer's <code
      >close</code
      > method will be called to indicate the end of the stream, which would be reflected on the reader side by <code
      >isComplete</code
      > returning true.</p
    ></div
  ><div id="groovy-streaminglogreader"
  ><h3
    ><a href="#TOC"
      >Groovy StreamingLogReader</a
      ></h3
    ><p
    >Create a groovy script that calls the <code
      >rundeckPlugin</code
      > method and passes the <code
      >StreamingLogReaderPlugin</code
      > as the type of plugin:</p
    ><pre
    ><code
      >import com.dtolabs.rundeck.plugins.logging.StreamingLogReaderPlugin
rundeckPlugin(StreamingLogReaderPlugin){
    //plugin definition
}
</code
      ></pre
    ><p
    >To define metadata about your plugin, and configuration properties, see the <a href="notification-plugin-development.html#definition"
      >Notification Plugin Development - Groovy Notification Plugins - DSL - Definition</a
      > chapter.</p
    ><p
    >Define these closures inside your definition:</p
    ><p
    ><code
      >info</code
      ></p
    ><pre
    ><code
      >/**
 * The 'info' closure is called to retrieve some metadata about the stream, 
 * such as whether it is available to read, totalSize of the content, and last
 *  modification time
 * 
 * It should return a Map containing these two entries:
 *  `ready` : a boolean indicating whether 'open' will work
 * `lastModified`: Long (unix epoch) or Date indicating last modification of the log
 * `totalSize`: Long indicating total size of the log, it doesn't have to indicate bytes,
 *     merely a measurement of total data size
 */
info {Map execution, Map configuration-&gt;

    //return map containing metadata about the stream
    // it SHOULD contain these two elements:
    [
        lastModified: determineLastModified(),
        totalSize: determineDataSize(),
        ready: isReady()
    ]
}
</code
      ></pre
    ><p
    ><code
      >open</code
      ></p
    ><pre
    ><code
      >/**
 * The `open` closure is called to begin reading events from the stream.
 * It is passed the execution data, the plugin configuration, and an offset.
 * It should return a Map containing any context to store between calls.
 */
open { Map execution, Map configuration, long offset -&gt;

    //return map of context data for your plugin to reuse later,
    [
        myfile: ...,
        mycounter:...
    ]
}
</code
      ></pre
    ><p
    ><code
      >next</code
      ></p
    ><pre
    ><code
      >/**
 * Next is called to produce the next event, it should return a Map
 * containing: [event: (event data), offset: (next offset), complete: (true/false)].  
 * The event data can be a LogEvent, or a Map containing:
 * [
 * message: (String),
 * loglevel: (String or LogLevel),
 * datetime: (long or Date),
 * eventType: (String),
 * metadata: (Map),
 * ]
 * `complete` should be true if no more events will ever be available.
 */
next { Map context-&gt;
    Map value=null
    boolean complete=false
    long offset=...
    try{
        value = readNextValue(...)
        complete = isComplete(..)
    }catch (SomeException e){
    }
    //event can be a Map, or a LogEvent
    return [event:event, offset:offset, complete:complete]
}
</code
      ></pre
    ><p
    ><code
      >close</code
      ></p
    ><pre
    ><code
      >/**
 * Close is called to finish the read stream
 */
close{ Map context-&gt;
    //perform any close action
}
</code
      ></pre
    ><p
    >The plugin is used in this manner:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >The <code
	>info</code
	> closure is called to determine the <code
	>lastModified</code
	> and <code
	>totalSize</code
	>.</li
      ><li
      >The <code
	>open</code
	> closure is called with both the <a href="#execution-context-data"
	>contextual data</a
	> about the execution, and any configuration property values, and the expected read offset</li
      ><li
      >The <code
	>next</code
	> closure is called repeatedly, until the result <code
	>event</code
	> entry is null, or <code
	>complete</code
	> is true. The <code
	>offset</code
	> value is reported to the client.</li
      ><li
      >The <code
	>close</code
	> closure is called with the context map.</li
      ></ol
    ></div
  ></div
><div id="logfilestorage"
><h2
  ><a href="#TOC"
    >LogFileStorage</a
    ></h2
  ><p
  >The <code
    >LogFileStorage</code
    > system is asked to store and retrieve entire log files for a specific execution.</p
  ><p
  >The Java interface for these plugins is:</p
  ><pre
  ><code
    >com.dtolabs.rundeck.plugins.logging.LogFileStoragePlugin
</code
    ></pre
  ><p
  >Log file storage allows Rundeck to store the log files elsewhere, in case local file storage is not suitable for long-term retention.</p
  ><p
  >When a LogFileStorage plugin is enabled, and the <strong
    >Local File Log</strong
    > streaming writer/reader is enabled, Rundeck will add this additional behavior:</p
  ><div id="storage-behavior"
  ><h3
    ><a href="#TOC"
      >Storage behavior</a
      ></h3
    ><p
    >After an execution completes, and the <strong
      >Local File Log</strong
      > finishes writing, Rundeck will place a <em
      >Storage Request</em
      > in an asynchronous queue for that Execution.</p
    ><p
    >When triggered, the <em
      >Storage Request</em
      > will use the configured LogFileStorage plugin and invoke <code
      >store</code
      >:</p
    ><ul
    ><li
      >If it is unsuccessful, Rundeck may re-queue the request to retry it after a delay (configurable)</li
      ></ul
    ></div
  ><div id="retrieval-behavior"
  ><h3
    ><a href="#TOC"
      >Retrieval behavior</a
      ></h3
    ><p
    >When a client requests a log stream to read via the <strong
      >Local File Log</strong
      >, Rundeck determines if the file is available locally. If it is not available, it will start a <em
      >Retrieval Request</em
      > asynchronously, and tell the client that the file is in a &quot;pending&quot; state.</p
    ><p
    >The <em
      >Retrieval Request</em
      > will use the configured LogFileStorage plugin, and invoke <code
      >retrieve</code
      >.</p
    ><p
    >If successful, the client requests to read the <strong
      >Local File Log</strong
      > should find the file available locally. If unsuccessful, the result may be cached for a period of time to report to the client. After that time, a new <em
      >Retrieval Request</em
      > may be started if requested by a client. After a certain number of attempts fail, further attempts will be disabled and return the cached status. The retry delay and number of attempts can be configured.</p
    ></div
  ><div id="log-file-availability"
  ><h3
    ><a href="#TOC"
      >Log File Availability</a
      ></h3
    ><p
    >Your plugin will be asked if the log file is 'available', and should report back one of:</p
    ><ul
    ><li
      ><code
	>true</code
	> - the plugin can retrieve the file</li
      ><li
      ><code
	>false</code
	> - the plugin cannot retrieve the file</li
      ></ul
    ><p
    >Only if <code
      >true</code
      > is reported will a <em
      >Retrieval Request</em
      > be created.</p
    ><p
    >If there is an error discovering availability, your plugin should throw an Exception with the error message to report.</p
    ></div
  ><div id="java-logfilestorage"
  ><h3
    ><a href="#TOC"
      >Java LogFileStorage</a
      ></h3
    ><p
    >Create a Java class that implements the <a href="https://github.com/dtolabs/rundeck/tree/core/src/main/java/com/dtolabs/rundeck/plugins/logging/LogFileStoragePlugin.java"
      >LogFileStoragePlugin</a
      > interface:</p
    ><pre
    ><code
      >/**
 * Plugin interface for Log file storage
 */
public interface LogFileStoragePlugin extends LogFileStorage {
    /**
     * Initializes the plugin with contextual data
     * @param context
     */
    public void initialize(Map&lt;String, ? extends Object&gt; context);

    /**
     * Returns true if the file is available, false otherwise
     * @return
     * @throws LogFileStorageException if there is an error determining the availability
     */
    public boolean isAvailable() throws LogFileStorageException;
}
</code
      ></pre
    ><p
    >This extends the the <a href="https://github.com/dtolabs/rundeck/tree/core/src/main/java/com/dtolabs/rundeck/core/logging/LogFileStorage.java"
      >LogFileStorage</a
      > interface:</p
    ><pre
    ><code
      >/**
 * Handles log file storage and retrieval
 */
public interface LogFileStorage {
    /**
     * Stores a log file read from the given stream
     *
     * @param stream the input stream
     * @param length the file length
     * @param lastModified the file modification time
     *
     * @return true if successful
     *
     * @throws IOException
     */
    boolean store(InputStream stream, long length, Date lastModified) throws IOException, LogFileStorageException;

    /**
     * Writes a log file to the given stream
     *
     * @param stream the output stream
     *
     * @return true if successful
     *
     * @throws IOException
     */
    boolean retrieve(OutputStream stream) throws IOException, LogFileStorageException;
}
</code
      ></pre
    ><p
    >The plugin is used in these two conditions:</p
    ><ul
    ><li
      >A log file needs to be stored via the plugin</li
      ><li
      ><p
	>A log file needs to be retrieved via the plugin</p
	></li
      ><li
      >When the plugin is instantiated, any configuration properties defined that have values to be resolved are set on the plugin instance</li
      ><li
      ><p
	>The <code
	  >initialize</code
	  > method is called with a map of <a href="#execution-context-data"
	  >contextual data</a
	  > about the execution</p
	></li
      ></ul
    ><p
    >When <code
      >retrieval</code
      > is needed:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >The <code
	>isAvailable</code
	> method is called to determine if the plugin can retrieve the file</li
      ><li
      >If the method returns true, then <code
	>retrieve</code
	> method is called.</li
      ></ol
    ><p
    >When <code
      >storage</code
      > is needed:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >The <code
	>store</code
	> method is called.</li
      ></ol
    ></div
  ><div id="groovy-logfilestorage"
  ><h3
    ><a href="#TOC"
      >Groovy LogFileStorage</a
      ></h3
    ><p
    >Create a groovy script that calls the <code
      >rundeckPlugin</code
      > method and passes the <code
      >LogFileStoragePlugin</code
      > as the type of plugin:</p
    ><pre
    ><code
      >import com.dtolabs.rundeck.plugins.logging.LogFileStoragePlugin
rundeckPlugin(LogFileStoragePlugin){
    //plugin definition
}
</code
      ></pre
    ><p
    >To define metadata about your plugin, and configuration properties, see the <a href="notification-plugin-development.html#definition"
      >Notification Plugin Development - Groovy Notification Plugins - DSL - Definition</a
      > chapter.</p
    ><p
    >Define these closures inside your definition:</p
    ><p
    ><code
      >available</code
      ></p
    ><pre
    ><code
      >/**
 * Called to determine the file availability, return true to indicate it is available, 
 * false to indicate it is not available. An exception indicates an error.
 */
available { Map execution, Map configuration-&gt;
    //determine state
    return isAvailable()
}
</code
      ></pre
    ><p
    ><code
      >store</code
      ></p
    ><pre
    ><code
      >/**
 * Called to store a log file, called with the execution data, configuration properties, and an InputStream.  Additionally `length` and `lastModified` properties are in the closure binding, providing the file length, and last modification Date.
 * Return true to indicate success.
 */
store { Map execution, Map configuration, InputStream source-&gt;
    //store output
    source.withReader { reader -&gt;
        //...write somewhere
    }
    source.close()
    //return true if successful
    true
}
</code
      ></pre
    ><p
    ><code
      >retrieve</code
      ></p
    ><pre
    ><code
      >/**
 * Called to retrieve a log file, called with the execution data, configuration properties, and an OutputStream.
 * Return true to indicate success.
 */
retrieve {  Map execution, Map configuration, OutputStream out-&gt;
    //get log file contents and write to output stream
    out &lt;&lt; retrieveIt()
    //return true to indicate success
    true
}
</code
      ></pre
    ><p
    >The plugin is used in this manner:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >The <code
	>available</code
	> closure is called before retrieving the file, to determine if it is available</li
      ><li
      >The <code
	>store</code
	> closure is called when a file needs to be stored, with the <a href="#execution-context-data"
	>contextual data</a
	>, configuration Map, and InputStream which will produce the log data. Additionally <code
	>length</code
	> and <code
	>lastModified</code
	> properties are in the closure binding, providing the file length, and last modification Date.</li
      ><li
      >The <code
	>retrieve</code
	> closure is called when a file needs to be retrieved, with the <a href="#execution-context-data"
	>contextual data</a
	>, configuration Map, and OutputStream to write the log file content</li
      ></ol
    ></div
  ></div
>
</div>

<nav class="page bottom">
    <ul>
        <li class="current"><a href="logging-plugin-development.html">Logging Plugin Development</a></li>
        <li class="toc"><a href="index.html">Developer Guide</a></li>
        <li class="prev"><a href="workflow-step-plugin-development.html">Workflow Step Plugin Development</a></li>
        <li class="next"><a href="plugin-development.html">Plugin Development</a></li>
    </ul>
</nav>
<nav class="breadcrumb bottom">
    <ul>
        <li><a href="../index.html">Rundeck Documentation (1.6.2)</a></li>
    </ul>
</nav>
<footer class="copy">

<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Rundeck Documentation</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://dtosolutions.com" property="cc:attributionName" rel="cc:attributionURL">SimplifyOps</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.

<br/>
&copy;2013 <a href="http://simplifyops.com">#SimplifyOps</a>
<br/>
<span class="generated-date" title="2013-09-19T20:23:24EDT">2013-09-19T20:23:24EDT</span>
  <script type="text/javascript">
  

   var _gaq = [['_setAccount', 'UA-529275-13'], ['_trackPageview']];
   (function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.async = true;
    g.src = ('https:' == location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g, s);
   })(document, 'script');
  </script>
</footer>
</body>
</html>
